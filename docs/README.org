
* Modelo

Usamos o modelo já conhecido para o TSP convencional como base

\begin{align*}
\min \sum c_{e} x_{e}& \\
\sum \limits_{e \in \delta(v)} x_{e} &= 2 v \in V \\
\sum \limits_{e \in \delta(S)} x_{e} &\leq |S| -1 S \subset V
\end{align*}

No nosso caso, temos que resolver dois TSP's mas que as soluções possuam $k$ arestas em comum.

No nosso modelo $x_{e}^{1}$ indica que usamos a aresta $e$ para o tuor $1$ o respectivo para o tuor 2 e $D_{e}$ indica se a aresta está duplicada.

Nossa função objetivo pode ser a soma dos custos dos dois tuors, ou seja
\[  \min \sum \limits_{e \in E} \sum \limits_{i \in \{1,2\}} c_{e} x_{e}^{i}. \]

Repetimos as restrições do TSP para cada um dos tuors.
\begin{align*}
\sum \limits_{e \in \delta(v)} x_{e}^{i} &= 2 v \in V \ \forall i \in \{1,2\} \\
\sum \limits_{e \in \delta(S)} x_{e}^{i} &\leq |S| -1 \ \forall S \subset V \ \forall i \in \{1,2\}
\end{align*}

É importante notar que a segunda equação dá origem a quantidade exponencial de restrições de eliminação de subtuor. No nosso código, podemos circundar esse problema adicionando as restrições conforme se faz necessário. Assim, quando o modelo termina com um certo conjunto de restrições, podemos conferir, por meio de uma busca de profundidade, se é uma solução viável considerando a restrição de subtuor. Caso não seja, adicionamos as restrições de subtuor que evitam essa solução. Fazemos isso até encontrarmos uma solução viável.

Por fim, adicionamos as restrições que exigem a quantidade de arestas compartilhadas.
\begin{align*}
x_{e}^{i} &\geq D_{e} \ \forall e \in E \ \forall i \in \{1,2\} \\
\sum \limits_{e \in E} D_{e} &\geq k
\end{align*}

Assim, nosso modelo final é
\begin{align*}
\min \sum \limits_{e \in E} \sum \limits_{i \in \{1,2\}} c_{e} x_{e}^{i}& \\
\sum \limits_{e \in \delta(v)} x_{e}^{i} &= 2 \ \forall v \in V \ \forall i \in \{1,2\} \\
\sum \limits_{e \in \delta(S)} x_{e}^{i} &\leq |S| -1 \ \forall S \subset V \forall i \in \{1,2\} \\
x_{e}^{i} &\geq D_{e} \ \forall e \in E \ \forall i \in \{1,2\} \\
\sum \limits_{e \in E} D_{e} &\geq k
\end{align*}

* Geração de instâncias
Para testar nosso modelo, utilizamos o arquivo de coordenadas disponibilizado pelo professor para calcular nossos custos de arestas. Assim, para instâncias de 100 cidades, utilizamos as 100 primeiras linhas do arquivo.

Durante os testes, modificamos a quantidade de cidades ($100$,$150$,$200$ e $250$) e o valor de $k$ (zero, metade da quantidade de cidades e a quantidade de cidades).
* Resultados

Realizamos os testes em um computador equipado de um processador i5 de oitava geração, com 4 cores e 8 threads a 1.6ghz (max boost 3.2) e 8gb de ram, sem swap. Na


#+caption: Métricas do modelo para as instâncias citadas.
| (custo, gap, tempo(s)) | $k=0$ | $k=\frac{v}{2}$ | $k = v$ |
|---------------------+---+---------------+-----|
|                 $v = 100$ | (1630, 0%, 12.46) |               |     |
|                 $v = 150$ | (1966, 0%, 79.01) |               |     |
|                 $v = 200$ |   |               |     |
|                 $v = 250$ |   |               |     |
* Análise
Observando as métricas obtidas, vemos os piores tempos de execução são encontrados quando $k = \frac{v}{2}$.
* Fontes
https://colab.research.google.com/github/Gurobi/modeling-examples/blob/master/traveling_salesman/tsp_gcl.ipynb
